import 'package:flutter/foundation.dart';
import 'dart:developer' as developer;
import 'package:hive/hive.dart'; // ğŸ”¥ ULTRA THINK: ì§ì ‘ Hive ì ‘ê·¼ì„ ìœ„í•œ import
import '../models/recipe.dart';
import '../models/mood.dart';
import '../models/burrow_milestone.dart';
import '../services/hive_service.dart';
import '../services/burrow_storage_service.dart';

/// í† ë¼êµ´ ë§ˆì¼ìŠ¤í†¤ ì–¸ë½ ì„œë¹„ìŠ¤
/// ì„±ì¥ íŠ¸ë™ê³¼ íŠ¹ë³„ ê³µê°„ì˜ ì–¸ë½ ì¡°ê±´ì„ ì²´í¬í•˜ê³  ê´€ë¦¬
class BurrowUnlockService {
  final HiveService _hiveService;
  final BurrowStorageService _storageService;
  
  // ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•œ ì²˜ë¦¬ëœ ë ˆì‹œí”¼ IDs ìºì‹œ
  final Set<String> _processedRecipeIds = <String>{};
  
  // ì–¸ë½ í (ë™ì‹œ ë‹¤ì¤‘ ì–¸ë½ ë°©ì§€)
  final List<UnlockQueueItem> _unlockQueue = [];
  
  // ğŸ”¥ CRITICAL FIX: HiveService ì‹±ê¸€í†¤ ê°•ì œ ì „ë‹¬ (ë” ì´ìƒ ë³„ë„ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë°©ì§€)
  BurrowUnlockService({
    required HiveService hiveService, // ğŸ”¥ CRITICAL: í•„ìˆ˜ ë§¤ê°œë³€ìˆ˜ë¡œ ë³€ê²½
    BurrowStorageService? storageService,
  }) : _hiveService = hiveService, // ğŸ”¥ CRITICAL: ì§ì ‘ í• ë‹¹
       _storageService = storageService ?? BurrowStorageService();
       
  // ğŸ”¥ CRITICAL FIX: ë ˆê±°ì‹œ ìƒì„±ì (deprecated, ì‚¬ìš© ê¸ˆì§€)
  @Deprecated('Use BurrowUnlockService(hiveService: HiveService()) instead')
  BurrowUnlockService.legacy({
    HiveService? hiveService,
    BurrowStorageService? storageService,
  }) : _hiveService = hiveService ?? HiveService(),
       _storageService = storageService ?? BurrowStorageService();

  /// ì´ˆê¸°í™” - ê¸°ë³¸ ë§ˆì¼ìŠ¤í†¤ ìƒì„± ë° ì§„í–‰ìƒí™© ë¡œë“œ
  Future<void> initialize() async {
    try {
      await _storageService.initialize();
      await _createDefaultMilestones();
      await _loadProgressData();
      developer.log('BurrowUnlockService initialized', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to initialize BurrowUnlockService: $e', name: 'BurrowUnlockService');
      rethrow;
    }
  }
  
  /// ê¸°ë³¸ ë§ˆì¼ìŠ¤í†¤ë“¤ ìƒì„±
  Future<void> _createDefaultMilestones() async {
    final existingMilestones = await _loadMilestones();
    if (existingMilestones.isNotEmpty) return; // ì´ë¯¸ ì¡´ì¬í•˜ë©´ ìƒì„±í•˜ì§€ ì•ŠìŒ
    
    final milestones = <BurrowMilestone>[
      // ì„±ì¥ íŠ¸ë™ (ë ˆì‹œí”¼ ìˆ˜ëŸ‰ ê¸°ë°˜)
      BurrowMilestone.growth(
        level: 1,
        requiredRecipes: 1,
        title: 'ì•„ëŠ‘í•œ í† ë¼êµ´',
        description: 'ì²« ë ˆì‹œí”¼ì™€ í•¨ê»˜ ì•„ëŠ‘í•œ í† ë¼êµ´ì„ ë§Œë“¤ì—ˆì–´ìš”',
      ),
      BurrowMilestone.growth(
        level: 2,
        requiredRecipes: 3,
        title: 'ê³ ë…í•œ í† ë¼êµ´',
        description: 'ì¡°ìš©í•œ ì‹œê°„ì„ ìœ„í•œ ê³ ë…í•œ í† ë¼êµ´ì´ ì™„ì„±ë˜ì—ˆì–´ìš”',
      ),
      BurrowMilestone.growth(
        level: 3,
        requiredRecipes: 5,
        title: 'ë”°ìŠ¤í•œ í† ë¼êµ´',
        description: 'ë”°ìŠ¤í•œ ê°ì •ë“¤ì´ ê°€ë“ ë‹´ê¸´ í† ë¼êµ´ì´ ë˜ì—ˆë„¤ìš”',
      ),
      BurrowMilestone.growth(
        level: 4,
        requiredRecipes: 7,
        title: 'ì„œì¬ í† ë¼êµ´',
        description: 'ì§€ì‹ê³¼ ì¶”ì–µì´ ìŒ“ì¸ ì„œì¬ í† ë¼êµ´ì´ ì™„ì„±ë˜ì—ˆì–´ìš”',
      ),
      BurrowMilestone.growth(
        level: 5,
        requiredRecipes: 10,
        title: 'ì˜¤ìˆœë„ìˆœ í† ë¼êµ´',
        description: 'ëª¨ë“  ê°ì •ì´ ì–´ìš°ëŸ¬ì§„ ì˜¤ìˆœë„ìˆœ í† ë¼êµ´ì˜ ì™„ì„±',
      ),
      
      // íŠ¹ë³„ ê³µê°„ë“¤ (ìˆ¨ê²¨ì§„ ì¡°ê±´ ê¸°ë°˜)
      BurrowMilestone.special(
        room: SpecialRoom.ballroom,
        title: 'ë¬´ë„íšŒì¥',
        description: 'ëˆ„êµ°ê°€ë¥¼ ìœ„í•œ ë”°ëœ»í•œ ë§ˆìŒì´ ì—´ì–´ì¤€ íŠ¹ë³„í•œ ê³µê°„',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.hotSpring,
        title: 'ì˜¨ì²œíƒ•',
        description: 'ì§€ì¹œ ë§ˆìŒì„ ë‹¬ë˜ëŠ” ìœ„ë¡œì˜ ê³µê°„',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.orchestra,
        title: 'ìŒì•…íšŒì¥',
        description: 'ë‹¤ì–‘í•œ ê°ì •ì˜ í•˜ëª¨ë‹ˆê°€ ë§Œë“  ì•„ë¦„ë‹¤ìš´ ê³µê°„',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.alchemyLab,
        title: 'ì—°ê¸ˆìˆ ì‹¤',
        description: 'ì‹¤íŒ¨ë¥¼ ì„±ê³µìœ¼ë¡œ ë°”ê¾¼ ë„ì „ì •ì‹ ì˜ ê³µê°„',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.fineDining,
        title: 'íŒŒì¸ë‹¤ì´ë‹',
        description: 'ì™„ë²½ì„ ì¶”êµ¬í•˜ëŠ” ì—´ì •ì´ ë§Œë“  ê³ ê¸‰ìŠ¤ëŸ¬ìš´ ê³µê°„',
      ),
    ];
    
    // Storage Serviceì— ì €ì¥
    await _storageService.saveMilestones(milestones);
    developer.log('Created ${milestones.length} default milestones', name: 'BurrowUnlockService');
  }
  
  /// ì§„í–‰ìƒí™© ë°ì´í„° ë¡œë“œ
  Future<void> _loadProgressData() async {
    try {
      final progressList = await _loadProgress();
      
      // ì²˜ë¦¬ëœ ë ˆì‹œí”¼ IDë“¤ì„ ìºì‹œì— ë¡œë“œ
      for (final progress in progressList) {
        _processedRecipeIds.addAll(progress.processedRecipeIds);
      }
      
      developer.log('Loaded ${_processedRecipeIds.length} processed recipe IDs', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to load progress data: $e', name: 'BurrowUnlockService');
    }
  }
  
  /// ìƒˆ ë ˆì‹œí”¼ì— ëŒ€í•œ ë§ˆì¼ìŠ¤í†¤ ì²´í¬ (ë©”ì¸ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸)
  Future<List<BurrowMilestone>> checkUnlocksForRecipe(Recipe recipe) async {
    if (_processedRecipeIds.contains(recipe.id)) {
      developer.log('Recipe ${recipe.id} already processed, skipping', name: 'BurrowUnlockService');
      return []; // ì´ë¯¸ ì²˜ë¦¬ëœ ë ˆì‹œí”¼ëŠ” ìŠ¤í‚µ (ì¤‘ë³µ ë°©ì§€)
    }
    
    final newUnlocks = <BurrowMilestone>[];
    
    try {
      // ì„±ì¥ íŠ¸ë™ ì²´í¬
      final growthUnlocks = await _checkGrowthTrack();
      newUnlocks.addAll(growthUnlocks);
      
      // íŠ¹ë³„ ê³µê°„ ì²´í¬ (ì„±ëŠ¥ ìµœì í™”: ì–¸ë½ë˜ì§€ ì•Šì€ ê²ƒë§Œ)
      final specialUnlocks = await _checkSpecialRooms(recipe);
      newUnlocks.addAll(specialUnlocks);
      
      // ì²˜ë¦¬ëœ ë ˆì‹œí”¼ ë§ˆí‚¹
      _processedRecipeIds.add(recipe.id);
      
      // ì–¸ë½ëœ ë§ˆì¼ìŠ¤í†¤ë“¤ì„ íì— ì¶”ê°€
      if (newUnlocks.isNotEmpty) {
        debugPrint('ğŸš¨ğŸš¨ğŸš¨ CRITICAL UNLOCK PROCESS: About to unlock ${newUnlocks.length} milestones');
        
        for (final milestone in newUnlocks) {
          debugPrint('ğŸš¨ BEFORE UNLOCK: L${milestone.level} isUnlocked = ${milestone.isUnlocked}');
          
          _unlockQueue.add(UnlockQueueItem(
            milestone: milestone,
            unlockedAt: DateTime.now(),
            triggerRecipeId: recipe.id,
          ));
          
          milestone.unlock();
          debugPrint('ğŸš¨ AFTER UNLOCK: L${milestone.level} isUnlocked = ${milestone.isUnlocked}');
        }
        
        debugPrint('ğŸš¨ğŸš¨ğŸš¨ CRITICAL: About to save ${newUnlocks.length} milestones to storage');
        
        // ğŸ”¥ CRITICAL FIX: ëª¨ë“  ë§ˆì¼ìŠ¤í†¤ì„ ë‹¤ì‹œ ë¡œë“œí•˜ê³ , ì–¸ë½ëœ ê²ƒë“¤ì„ ì—…ë°ì´íŠ¸
        final allMilestones = await _loadMilestones();
        
        // ì–¸ë½ëœ ë§ˆì¼ìŠ¤í†¤ë“¤ì„ ì°¾ì•„ì„œ unlock ìƒíƒœ ì ìš©
        for (final unlockedMilestone in newUnlocks) {
          final storageIndex = allMilestones.indexWhere((m) => m.id == unlockedMilestone.id);
          if (storageIndex != -1) {
            debugPrint('ğŸš¨ APPLYING UNLOCK to storage milestone L${allMilestones[storageIndex].level}');
            allMilestones[storageIndex].unlock();
            debugPrint('ğŸš¨ Storage milestone L${allMilestones[storageIndex].level} now unlocked: ${allMilestones[storageIndex].isUnlocked}');
          }
        }
        
        await _updateMilestones(allMilestones);
        
        debugPrint('ğŸš¨ğŸš¨ğŸš¨ CRITICAL: Milestone save completed - checking if persisted');
        final checkMilestones = await _loadMilestones();
        final checkGrowth = checkMilestones.where((m) => m.isGrowthTrack).toList();
        for (final milestone in checkGrowth) {
          debugPrint('ğŸš¨ VERIFICATION: L${milestone.level} isUnlocked = ${milestone.isUnlocked}');
        }
        
        developer.log('Unlocked ${newUnlocks.length} milestones for recipe ${recipe.id}', name: 'BurrowUnlockService');
      }
      
    } catch (e) {
      developer.log('Failed to check unlocks for recipe ${recipe.id}: $e', name: 'BurrowUnlockService');
      // ì—ëŸ¬ ë°œìƒì‹œ ì²˜ë¦¬ëœ ë ˆì‹œí”¼ì—ì„œ ì œê±° (ì¬ì‹œë„ ê°€ëŠ¥í•˜ë„ë¡)
      _processedRecipeIds.remove(recipe.id);
    }
    
    return newUnlocks;
  }
  
  /// ì„±ì¥ íŠ¸ë™ ë§ˆì¼ìŠ¤í†¤ ì²´í¬
  Future<List<BurrowMilestone>> _checkGrowthTrack() async {
    debugPrint('ğŸš¨ğŸš¨ğŸš¨ CRITICAL: _checkGrowthTrack STARTED');
    
    // ğŸ”¥ CRITICAL DEBUG: HiveService ì¸ìŠ¤í„´ìŠ¤ ì •ë³´ ë¡œê¹…
    debugPrint('ğŸ”¥ DEBUG: BurrowUnlockService HiveService instance: ${_hiveService.hashCode}');
    
    // ğŸ”¥ CRITICAL FIX: ë” ê¸´ ì§€ì—° (ë°•ìŠ¤ ë™ê¸°í™” ë³´ì¥)
    debugPrint('ğŸ”¥ DEBUG: Waiting for box synchronization...');
    await Future.delayed(Duration(milliseconds: 300)); // ì¦ê°€ëœ ëŒ€ê¸° ì‹œê°„
    
    // ğŸ”¥ CRITICAL FIX: ë³€ìˆ˜ ì„ ì–¸ì„ ìŠ¤ì½”í”„ ë°–ìœ¼ë¡œ ì´ë™
    List<Recipe> allRecipes = [];
    int recipeCount = 0;
    
    try {
      // ğŸ”¥ CRITICAL DEBUG: ë‹¨ê³„ë³„ ë””ë²„ê·¸
      debugPrint('ğŸ”¥ DEBUG: About to call _hiveService.getAllRecipes()...');
      
      allRecipes = await _hiveService.getAllRecipes();
      recipeCount = allRecipes.length;
      
      debugPrint('ğŸš¨ğŸš¨ğŸš¨ CRITICAL RESULT: HiveService returned $recipeCount recipes');
      debugPrint('ğŸ”¥ DEBUG: Recipe list type: ${allRecipes.runtimeType}');
      debugPrint('ğŸ”¥ DEBUG: Is list empty: ${allRecipes.isEmpty}');
      
      // ğŸ”¥ ULTRA THINK: HiveServiceë¥¼ ì™„ì „íˆ ìš°íšŒí•˜ì—¬ ì§ì ‘ Hive.box() ì ‘ê·¼
      debugPrint('ğŸ”¥ ULTRA DEBUG: Bypassing HiveService, accessing Hive.box directly...');
      try {
        final directBox = Hive.box<Map<String, dynamic>>('recipes');
        debugPrint('ğŸ”¥ DIRECT ACCESS: Direct box hashCode: ${directBox.hashCode}');
        debugPrint('ğŸ”¥ DIRECT ACCESS: Direct box isOpen: ${directBox.isOpen}');
        debugPrint('ğŸ”¥ DIRECT ACCESS: Direct box length: ${directBox.length}');
        debugPrint('ğŸ”¥ DIRECT ACCESS: Direct box keys: ${directBox.keys.toList()}');
        
        if (directBox.length > 0) {
          debugPrint('ğŸ”¥ DIRECT ACCESS: SUCCESS! Found ${directBox.length} recipes in direct box');
          // ì§ì ‘ Boxì—ì„œ ë ˆì‹œí”¼ ì½ê¸°
          final directRecipes = directBox.values
              .map((jsonData) => Recipe.fromJson(jsonData))
              .toList();
          debugPrint('ğŸ”¥ DIRECT ACCESS: Successfully parsed ${directRecipes.length} recipes');
          
          // ğŸ”¥ ULTRA CRITICAL: ì§ì ‘ ì ‘ê·¼ì—ì„œ ë°ì´í„°ê°€ ìˆë‹¤ë©´, HiveService ë¬¸ì œ í™•ì‹¤!
          allRecipes = directRecipes;
          recipeCount = directRecipes.length;
          debugPrint('ğŸ”¥ CRITICAL FIX: Using direct box data - $recipeCount recipes found!');
        } else {
          debugPrint('ğŸ”¥ DIRECT ACCESS: Direct box also empty - data truly not saved');
        }
      } catch (directError) {
        debugPrint('ğŸ”¥ DIRECT ACCESS ERROR: $directError');
      }
      
      if (recipeCount > 0) {
        debugPrint('ğŸ”¥ SUCCESS: Found recipes in BurrowUnlockService!');
        for (int i = 0; i < allRecipes.length && i < 3; i++) {
          debugPrint('ğŸš¨ Recipe $i: "${allRecipes[i].title}" (ID: ${allRecipes[i].id})');
        }
        if (recipeCount > 3) {
          debugPrint('ğŸš¨ ... and ${recipeCount - 3} more recipes');
        }
      } else {
        debugPrint('ğŸš¨ğŸš¨ğŸš¨ CRITICAL ERROR: NO RECIPES FOUND IN BURROW SERVICE!');
        debugPrint('ğŸ”¥ DEBUG: This indicates the HiveService instances are not synchronized');
        
        // ğŸ”¥ CRITICAL DEBUG: ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜
        for (int retry = 1; retry <= 3; retry++) {
          debugPrint('ğŸ”¥ RETRY $retry: Attempting to read recipes again...');
          await Future.delayed(Duration(milliseconds: 500 * retry));
          
          final retryRecipes = await _hiveService.getAllRecipes();
          if (retryRecipes.isNotEmpty) {
            debugPrint('ğŸ”¥ SUCCESS on retry $retry: Found ${retryRecipes.length} recipes');
            return await _checkGrowthTrack(); // ì¬ê·€ í˜¸ì¶œ
          } else {
            debugPrint('ğŸ”¥ RETRY $retry FAILED: Still 0 recipes');
          }
        }
      }
      
      developer.log('ğŸ”¥ UNLOCK DEBUG: Total recipes in Hive: $recipeCount', name: 'BurrowUnlockService');
      
    } catch (e) {
      debugPrint('ğŸš¨ ERROR in _checkGrowthTrack getAllRecipes: $e');
      developer.log('ERROR in getAllRecipes: $e', name: 'BurrowUnlockService');
      return [];
    }
    
    final milestones = await _loadMilestones();
    final growthMilestones = milestones.where((m) => m.isGrowthTrack).toList();
    
    debugPrint('ğŸš¨ğŸš¨ğŸš¨ CRITICAL: Found ${growthMilestones.length} growth milestones');
    
    developer.log('ğŸ”¥ UNLOCK DEBUG: Growth milestones loaded: ${growthMilestones.length}', name: 'BurrowUnlockService');
    
    final newUnlocks = <BurrowMilestone>[];
    
    for (final milestone in growthMilestones) {
      developer.log('ğŸ”¥ UNLOCK DEBUG: Checking milestone L${milestone.level}: unlocked=${milestone.isUnlocked}, needs=${milestone.requiredRecipes}, current=$recipeCount', name: 'BurrowUnlockService');
      
      if (!milestone.isUnlocked && milestone.requiredRecipes != null) {
        if (recipeCount >= milestone.requiredRecipes!) {
          developer.log('ğŸ”¥ UNLOCK DEBUG: âœ… UNLOCKING milestone L${milestone.level}!', name: 'BurrowUnlockService');
          newUnlocks.add(milestone);
        } else {
          developer.log('ğŸ”¥ UNLOCK DEBUG: âŒ Not enough recipes for L$milestone.level ($recipeCount/$milestone.requiredRecipes)', name: 'BurrowUnlockService');
        }
      } else {
        developer.log('ğŸ”¥ UNLOCK DEBUG: â­ï¸  Skipping L${milestone.level} (already unlocked or no recipe requirement)', name: 'BurrowUnlockService');
      }
    }
    
    developer.log('ğŸ”¥ UNLOCK DEBUG: Found ${newUnlocks.length} new growth unlocks', name: 'BurrowUnlockService');
    return newUnlocks;
  }
  
  /// íŠ¹ë³„ ê³µê°„ ë§ˆì¼ìŠ¤í†¤ ì²´í¬
  Future<List<BurrowMilestone>> _checkSpecialRooms(Recipe triggerRecipe) async {
    final milestones = await _loadMilestones();
    final specialMilestones = milestones.where((m) => m.isSpecialRoom && !m.isUnlocked).toList();
    
    final newUnlocks = <BurrowMilestone>[];
    
    for (final milestone in specialMilestones) {
      if (milestone.specialRoom != null) {
        final shouldUnlock = await _checkSpecialRoomCondition(milestone.specialRoom!, triggerRecipe);
        if (shouldUnlock) {
          newUnlocks.add(milestone);
        }
      }
    }
    
    return newUnlocks;
  }
  
  /// ê°œë³„ íŠ¹ë³„ ê³µê°„ ì–¸ë½ ì¡°ê±´ ì²´í¬
  Future<bool> _checkSpecialRoomCondition(SpecialRoom room, Recipe triggerRecipe) async {
    switch (room) {
      case SpecialRoom.ballroom:
        return await _checkBallroomCondition(triggerRecipe);
      case SpecialRoom.hotSpring:
        return await _checkHotSpringCondition(triggerRecipe);
      case SpecialRoom.orchestra:
        return await _checkOrchestraCondition(triggerRecipe);
      case SpecialRoom.alchemyLab:
        return await _checkAlchemyLabCondition(triggerRecipe);
      case SpecialRoom.fineDining:
        return await _checkFineDiningCondition(triggerRecipe);
    }
  }
  
  /// ë¬´ë„íšŒì¥ ì¡°ê±´: ì‚¬êµì  ìš”ë¦¬ì‚¬ (10ê°œ ë ˆì‹œí”¼ì—ì„œ 3ëª… ì´ìƒ ì–¸ê¸‰)
  Future<bool> _checkBallroomCondition(Recipe triggerRecipe) async {
    final progress = await _getOrCreateProgress(SpecialRoom.ballroom, 10);
    
    // ì´ë¯¸ ì²˜ë¦¬ëœ ë ˆì‹œí”¼ë©´ ìŠ¤í‚µ
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // ê°ì • ìŠ¤í† ë¦¬ì—ì„œ ì‚¬ëŒ ì–¸ê¸‰ ì²´í¬
    final mentionedPeople = _extractMentionedPeople(triggerRecipe.emotionalStory);
    
    if (mentionedPeople.isNotEmpty) {
      // ìƒˆë¡œ ì–¸ê¸‰ëœ ì‚¬ëŒë“¤ì„ ë©”íƒ€ë°ì´í„°ì— ì¶”ê°€
      final existingPeople = Set<String>.from(progress.getMetadata<List>('mentionedPeople') ?? []);
      existingPeople.addAll(mentionedPeople);
      progress.setMetadata('mentionedPeople', existingPeople.toList());
      
      // ë ˆì‹œí”¼ ì²˜ë¦¬ ë§ˆí‚¹ ë° ì¹´ìš´íŠ¸ ì¦ê°€
      if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
        progress.incrementCount();
        
        developer.log('Ballroom progress: ${progress.currentCount}/10, people: ${existingPeople.length}', 
                     name: 'BurrowUnlockService');
        
        await _saveProgress([progress]);
        
        // ì¡°ê±´ í™•ì¸: 10ê°œ ë ˆì‹œí”¼ + 3ëª… ì´ìƒ ì–¸ê¸‰
        return progress.isCompleted && existingPeople.length >= 3;
      }
    }
    
    return false;
  }
  
  /// ê°ì • ìŠ¤í† ë¦¬ì—ì„œ ì‚¬ëŒ ì–¸ê¸‰ ì¶”ì¶œ
  Set<String> _extractMentionedPeople(String emotionalStory) {
    final people = <String>{};
    final story = emotionalStory.toLowerCase();
    
    // í•œêµ­ì–´ ê´€ê³„ í‚¤ì›Œë“œë“¤
    const relationKeywords = [
      'ì—„ë§ˆ', 'ì•„ë¹ ', 'ë¶€ëª¨ë‹˜', 'ì–´ë¨¸ë‹ˆ', 'ì•„ë²„ì§€',
      'ê°€ì¡±', 'í˜•', 'ëˆ„ë‚˜', 'ì–¸ë‹ˆ', 'ë™ìƒ', 'ì˜¤ë¹ ',
      'ì¹œêµ¬', 'ë™ë£Œ', 'ì„ ë°°', 'í›„ë°°', 'ë™ê¸°',
      'ë‚¨ìì¹œêµ¬', 'ì—¬ìì¹œêµ¬', 'ì—°ì¸', 'ì• ì¸', 'ë‚¨í¸', 'ì•„ë‚´',
      'í• ë¨¸ë‹ˆ', 'í• ì•„ë²„ì§€', 'ì´ëª¨', 'ì‚¼ì´Œ', 'ê³ ëª¨', 'ì™¸ì‚¼ì´Œ',
      'ì•„ì´', 'ë”¸', 'ì•„ë“¤', 'ì†ì', 'ì†ë…€',
      'ì„ ìƒë‹˜', 'êµìˆ˜ë‹˜', 'ì‚¬ì¥ë‹˜', 'íŒ€ì¥ë‹˜',
      'ì´ì›ƒ', 'ë£¸ë©”ì´íŠ¸', 'ë°˜ë ¤ë™ë¬¼'
    ];
    
    for (final keyword in relationKeywords) {
      if (story.contains(keyword)) {
        people.add(keyword);
      }
    }
    
    return people;
  }
  
  /// ì˜¨ì²œíƒ• ì¡°ê±´: íë§ ìš”ë¦¬ì‚¬ (sad/tired/nostalgic ê° 3ê°œì”©)
  Future<bool> _checkHotSpringCondition(Recipe triggerRecipe) async {
    if (![Mood.sad, Mood.tired, Mood.nostalgic].contains(triggerRecipe.mood)) {
      return false; // íë§ ê°ì •ì´ ì•„ë‹ˆë©´ ì²´í¬í•˜ì§€ ì•ŠìŒ
    }
    
    final progress = await _getOrCreateProgress(SpecialRoom.hotSpring, 9); // ì´ 9ê°œ (ê° 3ê°œì”©)
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // ê°ì •ë³„ ì¹´ìš´íŠ¸ ì¶”ì 
    final moodCounts = Map<String, int>.from(progress.getMetadata<Map>('moodCounts') ?? {});
    final moodKey = triggerRecipe.mood.name;
    
    if ((moodCounts[moodKey] ?? 0) < 3) {
      moodCounts[moodKey] = (moodCounts[moodKey] ?? 0) + 1;
      progress.setMetadata('moodCounts', moodCounts);
      
      if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
        progress.incrementCount();
        
        developer.log('HotSpring progress: $moodCounts', name: 'BurrowUnlockService');
        
        await _saveProgress([progress]);
        
        // ì¡°ê±´ í™•ì¸: sad, tired, nostalgic ê°ê° 3ê°œ ì´ìƒ
        return (moodCounts['sad'] ?? 0) >= 3 &&
               (moodCounts['tired'] ?? 0) >= 3 &&
               (moodCounts['nostalgic'] ?? 0) >= 3;
      }
    }
    
    return false;
  }
  
  /// ìŒì•…íšŒì¥ ì¡°ê±´: ê°ì • ë§ˆì—ìŠ¤íŠ¸ë¡œ (8ê°€ì§€ ê°ì • ëª¨ë‘ ì™„ì„±, í‰ì  3+ )
  Future<bool> _checkOrchestraCondition(Recipe triggerRecipe) async {
    // í‰ì  3 ë¯¸ë§Œì´ë©´ ì²´í¬í•˜ì§€ ì•ŠìŒ
    if (triggerRecipe.rating == null || triggerRecipe.rating! < 3) {
      return false;
    }
    
    final progress = await _getOrCreateProgress(SpecialRoom.orchestra, 8); // 8ê°€ì§€ ê°ì •
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // ê°ì •ë³„ ë‹¬ì„± ì—¬ë¶€ ì¶”ì 
    final achievedMoods = Set<String>.from(progress.getMetadata<List>('achievedMoods') ?? []);
    final moodKey = triggerRecipe.mood.name;
    
    if (!achievedMoods.contains(moodKey)) {
      achievedMoods.add(moodKey);
      progress.setMetadata('achievedMoods', achievedMoods.toList());
      
      if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
        progress.currentCount = achievedMoods.length; // ì§ì ‘ ì„¤ì •
        
        developer.log('Orchestra progress: ${achievedMoods.length}/8 moods', name: 'BurrowUnlockService');
        
        await _saveProgress([progress]);
        
        // ì¡°ê±´ í™•ì¸: 8ê°€ì§€ ê°ì • ëª¨ë‘ ë‹¬ì„±
        return achievedMoods.length >= 8;
      }
    }
    
    return false;
  }
  
  /// ì—°ê¸ˆìˆ ì‹¤ ì¡°ê±´: ë„ì „ì  ìš”ë¦¬ì‚¬ (ì‹¤íŒ¨â†’ì„±ê³µ 3íšŒ)
  Future<bool> _checkAlchemyLabCondition(Recipe triggerRecipe) async {
    final progress = await _getOrCreateProgress(SpecialRoom.alchemyLab, 3);
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // ë™ì¼í•œ ì œëª©ì˜ ì´ì „ ë ˆì‹œí”¼ë“¤ ì°¾ê¸°
    final allRecipes = await _hiveService.getAllRecipes();
    final sameTitle = triggerRecipe.title.toLowerCase().trim();
    
    final relatedRecipes = allRecipes.where((r) => 
        r.title.toLowerCase().trim() == sameTitle &&
        r.id != triggerRecipe.id &&
        r.rating != null
    ).toList();
    
    if (relatedRecipes.isNotEmpty) {
      // ì´ì „ í‰ì  ì¤‘ 2ì  ì´í•˜ê°€ ìˆê³ , í˜„ì¬ í‰ì ì´ 4ì  ì´ìƒì¸ì§€ ì²´í¬
      final hasFailure = relatedRecipes.any((r) => r.rating! <= 2);
      final currentSuccess = triggerRecipe.rating != null && triggerRecipe.rating! >= 4;
      
      if (hasFailure && currentSuccess) {
        if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
          progress.incrementCount();
          
          developer.log('AlchemyLab progress: ${progress.currentCount}/3 improvements', name: 'BurrowUnlockService');
          
          await _saveProgress([progress]);
          
          return progress.isCompleted;
        }
      }
    }
    
    return false;
  }
  
  /// íŒŒì¸ë‹¤ì´ë‹ ì¡°ê±´: ì™„ë²½ì£¼ì˜ì (í‰ì  5ì  ë ˆì‹œí”¼ 10ê°œ)
  Future<bool> _checkFineDiningCondition(Recipe triggerRecipe) async {
    if (triggerRecipe.rating != 5) {
      return false; // 5ì ì´ ì•„ë‹ˆë©´ ì²´í¬í•˜ì§€ ì•ŠìŒ
    }
    
    final progress = await _getOrCreateProgress(SpecialRoom.fineDining, 10);
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
      progress.incrementCount();
      
      developer.log('FineDining progress: ${progress.currentCount}/10 perfect recipes', name: 'BurrowUnlockService');
      
      await _saveProgress([progress]);
      
      return progress.isCompleted;
    }
    
    return false;
  }
  
  /// ì§„í–‰ìƒí™© ê°€ì ¸ì˜¤ê¸° ë˜ëŠ” ìƒì„±
  Future<UnlockProgress> _getOrCreateProgress(SpecialRoom room, int requiredCount) async {
    final progressList = await _loadProgress();
    final existing = progressList.firstWhere(
      (p) => p.roomType == room,
      orElse: () => UnlockProgress(roomType: room, requiredCount: requiredCount),
    );
    
    return existing;
  }
  
  /// ì–¸ë½ íì—ì„œ ë‹¤ìŒ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸° (ìˆœì°¨ ì²˜ë¦¬ìš©)
  UnlockQueueItem? popUnlockQueue() {
    if (_unlockQueue.isEmpty) return null;
    return _unlockQueue.removeAt(0);
  }
  
  /// ì–¸ë½ í í¬ê¸° 
  int get unlockQueueSize => _unlockQueue.length;
  
  /// ëª¨ë“  ë§ˆì¼ìŠ¤í†¤ ê°€ì ¸ì˜¤ê¸°
  Future<List<BurrowMilestone>> getAllMilestones() async {
    return await _loadMilestones();
  }
  
  /// ì„±ì¥ íŠ¸ë™ ë§ˆì¼ìŠ¤í†¤ë“¤ ê°€ì ¸ì˜¤ê¸°
  Future<List<BurrowMilestone>> getGrowthMilestones() async {
    final milestones = await _loadMilestones();
    return milestones.where((m) => m.isGrowthTrack).toList()
      ..sort((a, b) => a.level.compareTo(b.level));
  }
  
  /// íŠ¹ë³„ ê³µê°„ ë§ˆì¼ìŠ¤í†¤ë“¤ ê°€ì ¸ì˜¤ê¸°
  Future<List<BurrowMilestone>> getSpecialMilestones() async {
    final milestones = await _loadMilestones();
    return milestones.where((m) => m.isSpecialRoom).toList();
  }
  
  /// í˜„ì¬ ì§„í–‰ìƒí™©ë“¤ ê°€ì ¸ì˜¤ê¸° (ë””ë²„ê·¸ìš©)
  Future<List<UnlockProgress>> getCurrentProgress() async {
    return await _loadProgress();
  }
  
  // === Hive ì €ì¥/ë¡œë“œ í—¬í¼ ë©”ì„œë“œë“¤ ===
  
  /// ë§ˆì¼ìŠ¤í†¤ë“¤ ë¡œë“œ
  Future<List<BurrowMilestone>> _loadMilestones() async {
    try {
      return await _storageService.loadMilestones();
    } catch (e) {
      developer.log('Failed to load milestones: $e', name: 'BurrowUnlockService');
      return [];
    }
  }
  
  /// ë‹¨ì¼ ë§ˆì¼ìŠ¤í†¤ ì—…ë°ì´íŠ¸ (public)
  Future<void> updateMilestone(BurrowMilestone milestone) async {
    try {
      await _storageService.updateMilestone(milestone);
      developer.log('Updated milestone: ${milestone.title}', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to update milestone: $e', name: 'BurrowUnlockService');
      rethrow;
    }
  }

  /// ë§ˆì¼ìŠ¤í†¤ë“¤ ì—…ë°ì´íŠ¸
  Future<void> _updateMilestones(List<BurrowMilestone> milestones) async {
    try {
      await _storageService.updateMilestones(milestones);
      developer.log('Updated ${milestones.length} milestones', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to update milestones: $e', name: 'BurrowUnlockService');
    }
  }
  
  /// ì§„í–‰ìƒí™©ë“¤ ì €ì¥
  Future<void> _saveProgress(List<UnlockProgress> progressList) async {
    try {
      await _storageService.saveProgress(progressList);
      developer.log('Saved ${progressList.length} progress items', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to save progress: $e', name: 'BurrowUnlockService');
    }
  }
  
  /// ì§„í–‰ìƒí™©ë“¤ ë¡œë“œ
  Future<List<UnlockProgress>> _loadProgress() async {
    try {
      return await _storageService.loadProgress();
    } catch (e) {
      developer.log('Failed to load progress: $e', name: 'BurrowUnlockService');
      return [];
    }
  }
}