import 'package:flutter/foundation.dart';
import 'dart:developer' as developer;
import 'package:hive/hive.dart'; // 🔥 ULTRA THINK: 직접 Hive 접근을 위한 import
import '../models/recipe.dart';
import '../models/mood.dart';
import '../models/burrow_milestone.dart';
import '../services/hive_service.dart';
import '../services/burrow_storage_service.dart';

/// 토끼굴 마일스톤 언락 서비스
/// 성장 트랙과 특별 공간의 언락 조건을 체크하고 관리
class BurrowUnlockService {
  final HiveService _hiveService;
  final BurrowStorageService _storageService;
  
  // 중복 방지를 위한 처리된 레시피 IDs 캐시
  final Set<String> _processedRecipeIds = <String>{};
  
  // 언락 큐 (동시 다중 언락 방지)
  final List<UnlockQueueItem> _unlockQueue = [];
  
  // 🔥 CRITICAL FIX: HiveService 싱글톤 강제 전달 (더 이상 별도 인스턴스 생성 방지)
  BurrowUnlockService({
    required HiveService hiveService, // 🔥 CRITICAL: 필수 매개변수로 변경
    BurrowStorageService? storageService,
  }) : _hiveService = hiveService, // 🔥 CRITICAL: 직접 할당
       _storageService = storageService ?? BurrowStorageService();
       
  // 🔥 CRITICAL FIX: 레거시 생성자 (deprecated, 사용 금지)
  @Deprecated('Use BurrowUnlockService(hiveService: HiveService()) instead')
  BurrowUnlockService.legacy({
    HiveService? hiveService,
    BurrowStorageService? storageService,
  }) : _hiveService = hiveService ?? HiveService(),
       _storageService = storageService ?? BurrowStorageService();

  /// 초기화 - 기본 마일스톤 생성 및 진행상황 로드
  Future<void> initialize() async {
    try {
      await _storageService.initialize();
      await _createDefaultMilestones();
      await _loadProgressData();
      developer.log('BurrowUnlockService initialized', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to initialize BurrowUnlockService: $e', name: 'BurrowUnlockService');
      rethrow;
    }
  }
  
  /// 기본 마일스톤들 생성
  Future<void> _createDefaultMilestones() async {
    final existingMilestones = await _loadMilestones();
    if (existingMilestones.isNotEmpty) return; // 이미 존재하면 생성하지 않음
    
    final milestones = <BurrowMilestone>[
      // 성장 트랙 (레시피 수량 기반)
      BurrowMilestone.growth(
        level: 1,
        requiredRecipes: 1,
        title: '아늑한 토끼굴',
        description: '첫 레시피와 함께 아늑한 토끼굴을 만들었어요',
      ),
      BurrowMilestone.growth(
        level: 2,
        requiredRecipes: 3,
        title: '고독한 토끼굴',
        description: '조용한 시간을 위한 고독한 토끼굴이 완성되었어요',
      ),
      BurrowMilestone.growth(
        level: 3,
        requiredRecipes: 5,
        title: '따스한 토끼굴',
        description: '따스한 감정들이 가득 담긴 토끼굴이 되었네요',
      ),
      BurrowMilestone.growth(
        level: 4,
        requiredRecipes: 7,
        title: '서재 토끼굴',
        description: '지식과 추억이 쌓인 서재 토끼굴이 완성되었어요',
      ),
      BurrowMilestone.growth(
        level: 5,
        requiredRecipes: 10,
        title: '오순도순 토끼굴',
        description: '모든 감정이 어우러진 오순도순 토끼굴의 완성',
      ),
      
      // 특별 공간들 (숨겨진 조건 기반)
      BurrowMilestone.special(
        room: SpecialRoom.ballroom,
        title: '무도회장',
        description: '누군가를 위한 따뜻한 마음이 열어준 특별한 공간',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.hotSpring,
        title: '온천탕',
        description: '지친 마음을 달래는 위로의 공간',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.orchestra,
        title: '음악회장',
        description: '다양한 감정의 하모니가 만든 아름다운 공간',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.alchemyLab,
        title: '연금술실',
        description: '실패를 성공으로 바꾼 도전정신의 공간',
      ),
      BurrowMilestone.special(
        room: SpecialRoom.fineDining,
        title: '파인다이닝',
        description: '완벽을 추구하는 열정이 만든 고급스러운 공간',
      ),
    ];
    
    // Storage Service에 저장
    await _storageService.saveMilestones(milestones);
    developer.log('Created ${milestones.length} default milestones', name: 'BurrowUnlockService');
  }
  
  /// 진행상황 데이터 로드
  Future<void> _loadProgressData() async {
    try {
      final progressList = await _loadProgress();
      
      // 처리된 레시피 ID들을 캐시에 로드
      for (final progress in progressList) {
        _processedRecipeIds.addAll(progress.processedRecipeIds);
      }
      
      developer.log('Loaded ${_processedRecipeIds.length} processed recipe IDs', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to load progress data: $e', name: 'BurrowUnlockService');
    }
  }
  
  /// 새 레시피에 대한 마일스톤 체크 (메인 엔트리포인트)
  Future<List<BurrowMilestone>> checkUnlocksForRecipe(Recipe recipe) async {
    if (_processedRecipeIds.contains(recipe.id)) {
      developer.log('Recipe ${recipe.id} already processed, skipping', name: 'BurrowUnlockService');
      return []; // 이미 처리된 레시피는 스킵 (중복 방지)
    }
    
    final newUnlocks = <BurrowMilestone>[];
    
    try {
      // 성장 트랙 체크
      final growthUnlocks = await _checkGrowthTrack();
      newUnlocks.addAll(growthUnlocks);
      
      // 특별 공간 체크 (성능 최적화: 언락되지 않은 것만)
      final specialUnlocks = await _checkSpecialRooms(recipe);
      newUnlocks.addAll(specialUnlocks);
      
      // 처리된 레시피 마킹
      _processedRecipeIds.add(recipe.id);
      
      // 언락된 마일스톤들을 큐에 추가
      if (newUnlocks.isNotEmpty) {
        debugPrint('🚨🚨🚨 CRITICAL UNLOCK PROCESS: About to unlock ${newUnlocks.length} milestones');
        
        for (final milestone in newUnlocks) {
          debugPrint('🚨 BEFORE UNLOCK: L${milestone.level} isUnlocked = ${milestone.isUnlocked}');
          
          _unlockQueue.add(UnlockQueueItem(
            milestone: milestone,
            unlockedAt: DateTime.now(),
            triggerRecipeId: recipe.id,
          ));
          
          milestone.unlock();
          debugPrint('🚨 AFTER UNLOCK: L${milestone.level} isUnlocked = ${milestone.isUnlocked}');
        }
        
        debugPrint('🚨🚨🚨 CRITICAL: About to save ${newUnlocks.length} milestones to storage');
        
        // 🔥 CRITICAL FIX: 모든 마일스톤을 다시 로드하고, 언락된 것들을 업데이트
        final allMilestones = await _loadMilestones();
        
        // 언락된 마일스톤들을 찾아서 unlock 상태 적용
        for (final unlockedMilestone in newUnlocks) {
          final storageIndex = allMilestones.indexWhere((m) => m.id == unlockedMilestone.id);
          if (storageIndex != -1) {
            debugPrint('🚨 APPLYING UNLOCK to storage milestone L${allMilestones[storageIndex].level}');
            allMilestones[storageIndex].unlock();
            debugPrint('🚨 Storage milestone L${allMilestones[storageIndex].level} now unlocked: ${allMilestones[storageIndex].isUnlocked}');
          }
        }
        
        await _updateMilestones(allMilestones);
        
        debugPrint('🚨🚨🚨 CRITICAL: Milestone save completed - checking if persisted');
        final checkMilestones = await _loadMilestones();
        final checkGrowth = checkMilestones.where((m) => m.isGrowthTrack).toList();
        for (final milestone in checkGrowth) {
          debugPrint('🚨 VERIFICATION: L${milestone.level} isUnlocked = ${milestone.isUnlocked}');
        }
        
        developer.log('Unlocked ${newUnlocks.length} milestones for recipe ${recipe.id}', name: 'BurrowUnlockService');
      }
      
    } catch (e) {
      developer.log('Failed to check unlocks for recipe ${recipe.id}: $e', name: 'BurrowUnlockService');
      // 에러 발생시 처리된 레시피에서 제거 (재시도 가능하도록)
      _processedRecipeIds.remove(recipe.id);
    }
    
    return newUnlocks;
  }
  
  /// 성장 트랙 마일스톤 체크
  Future<List<BurrowMilestone>> _checkGrowthTrack() async {
    debugPrint('🚨🚨🚨 CRITICAL: _checkGrowthTrack STARTED');
    
    // 🔥 CRITICAL DEBUG: HiveService 인스턴스 정보 로깅
    debugPrint('🔥 DEBUG: BurrowUnlockService HiveService instance: ${_hiveService.hashCode}');
    
    // 🔥 CRITICAL FIX: 더 긴 지연 (박스 동기화 보장)
    debugPrint('🔥 DEBUG: Waiting for box synchronization...');
    await Future.delayed(Duration(milliseconds: 300)); // 증가된 대기 시간
    
    // 🔥 CRITICAL FIX: 변수 선언을 스코프 밖으로 이동
    List<Recipe> allRecipes = [];
    int recipeCount = 0;
    
    try {
      // 🔥 CRITICAL DEBUG: 단계별 디버그
      debugPrint('🔥 DEBUG: About to call _hiveService.getAllRecipes()...');
      
      allRecipes = await _hiveService.getAllRecipes();
      recipeCount = allRecipes.length;
      
      debugPrint('🚨🚨🚨 CRITICAL RESULT: HiveService returned $recipeCount recipes');
      debugPrint('🔥 DEBUG: Recipe list type: ${allRecipes.runtimeType}');
      debugPrint('🔥 DEBUG: Is list empty: ${allRecipes.isEmpty}');
      
      // 🔥 ULTRA THINK: HiveService를 완전히 우회하여 직접 Hive.box() 접근
      debugPrint('🔥 ULTRA DEBUG: Bypassing HiveService, accessing Hive.box directly...');
      try {
        final directBox = Hive.box<Map<String, dynamic>>('recipes');
        debugPrint('🔥 DIRECT ACCESS: Direct box hashCode: ${directBox.hashCode}');
        debugPrint('🔥 DIRECT ACCESS: Direct box isOpen: ${directBox.isOpen}');
        debugPrint('🔥 DIRECT ACCESS: Direct box length: ${directBox.length}');
        debugPrint('🔥 DIRECT ACCESS: Direct box keys: ${directBox.keys.toList()}');
        
        if (directBox.length > 0) {
          debugPrint('🔥 DIRECT ACCESS: SUCCESS! Found ${directBox.length} recipes in direct box');
          // 직접 Box에서 레시피 읽기
          final directRecipes = directBox.values
              .map((jsonData) => Recipe.fromJson(jsonData))
              .toList();
          debugPrint('🔥 DIRECT ACCESS: Successfully parsed ${directRecipes.length} recipes');
          
          // 🔥 ULTRA CRITICAL: 직접 접근에서 데이터가 있다면, HiveService 문제 확실!
          allRecipes = directRecipes;
          recipeCount = directRecipes.length;
          debugPrint('🔥 CRITICAL FIX: Using direct box data - $recipeCount recipes found!');
        } else {
          debugPrint('🔥 DIRECT ACCESS: Direct box also empty - data truly not saved');
        }
      } catch (directError) {
        debugPrint('🔥 DIRECT ACCESS ERROR: $directError');
      }
      
      if (recipeCount > 0) {
        debugPrint('🔥 SUCCESS: Found recipes in BurrowUnlockService!');
        for (int i = 0; i < allRecipes.length && i < 3; i++) {
          debugPrint('🚨 Recipe $i: "${allRecipes[i].title}" (ID: ${allRecipes[i].id})');
        }
        if (recipeCount > 3) {
          debugPrint('🚨 ... and ${recipeCount - 3} more recipes');
        }
      } else {
        debugPrint('🚨🚨🚨 CRITICAL ERROR: NO RECIPES FOUND IN BURROW SERVICE!');
        debugPrint('🔥 DEBUG: This indicates the HiveService instances are not synchronized');
        
        // 🔥 CRITICAL DEBUG: 재시도 메커니즘
        for (int retry = 1; retry <= 3; retry++) {
          debugPrint('🔥 RETRY $retry: Attempting to read recipes again...');
          await Future.delayed(Duration(milliseconds: 500 * retry));
          
          final retryRecipes = await _hiveService.getAllRecipes();
          if (retryRecipes.isNotEmpty) {
            debugPrint('🔥 SUCCESS on retry $retry: Found ${retryRecipes.length} recipes');
            return await _checkGrowthTrack(); // 재귀 호출
          } else {
            debugPrint('🔥 RETRY $retry FAILED: Still 0 recipes');
          }
        }
      }
      
      developer.log('🔥 UNLOCK DEBUG: Total recipes in Hive: $recipeCount', name: 'BurrowUnlockService');
      
    } catch (e) {
      debugPrint('🚨 ERROR in _checkGrowthTrack getAllRecipes: $e');
      developer.log('ERROR in getAllRecipes: $e', name: 'BurrowUnlockService');
      return [];
    }
    
    final milestones = await _loadMilestones();
    final growthMilestones = milestones.where((m) => m.isGrowthTrack).toList();
    
    debugPrint('🚨🚨🚨 CRITICAL: Found ${growthMilestones.length} growth milestones');
    
    developer.log('🔥 UNLOCK DEBUG: Growth milestones loaded: ${growthMilestones.length}', name: 'BurrowUnlockService');
    
    final newUnlocks = <BurrowMilestone>[];
    
    for (final milestone in growthMilestones) {
      developer.log('🔥 UNLOCK DEBUG: Checking milestone L${milestone.level}: unlocked=${milestone.isUnlocked}, needs=${milestone.requiredRecipes}, current=$recipeCount', name: 'BurrowUnlockService');
      
      if (!milestone.isUnlocked && milestone.requiredRecipes != null) {
        if (recipeCount >= milestone.requiredRecipes!) {
          developer.log('🔥 UNLOCK DEBUG: ✅ UNLOCKING milestone L${milestone.level}!', name: 'BurrowUnlockService');
          newUnlocks.add(milestone);
        } else {
          developer.log('🔥 UNLOCK DEBUG: ❌ Not enough recipes for L$milestone.level ($recipeCount/$milestone.requiredRecipes)', name: 'BurrowUnlockService');
        }
      } else {
        developer.log('🔥 UNLOCK DEBUG: ⏭️  Skipping L${milestone.level} (already unlocked or no recipe requirement)', name: 'BurrowUnlockService');
      }
    }
    
    developer.log('🔥 UNLOCK DEBUG: Found ${newUnlocks.length} new growth unlocks', name: 'BurrowUnlockService');
    return newUnlocks;
  }
  
  /// 특별 공간 마일스톤 체크
  Future<List<BurrowMilestone>> _checkSpecialRooms(Recipe triggerRecipe) async {
    final milestones = await _loadMilestones();
    final specialMilestones = milestones.where((m) => m.isSpecialRoom && !m.isUnlocked).toList();
    
    final newUnlocks = <BurrowMilestone>[];
    
    for (final milestone in specialMilestones) {
      if (milestone.specialRoom != null) {
        final shouldUnlock = await _checkSpecialRoomCondition(milestone.specialRoom!, triggerRecipe);
        if (shouldUnlock) {
          newUnlocks.add(milestone);
        }
      }
    }
    
    return newUnlocks;
  }
  
  /// 개별 특별 공간 언락 조건 체크
  Future<bool> _checkSpecialRoomCondition(SpecialRoom room, Recipe triggerRecipe) async {
    switch (room) {
      case SpecialRoom.ballroom:
        return await _checkBallroomCondition(triggerRecipe);
      case SpecialRoom.hotSpring:
        return await _checkHotSpringCondition(triggerRecipe);
      case SpecialRoom.orchestra:
        return await _checkOrchestraCondition(triggerRecipe);
      case SpecialRoom.alchemyLab:
        return await _checkAlchemyLabCondition(triggerRecipe);
      case SpecialRoom.fineDining:
        return await _checkFineDiningCondition(triggerRecipe);
    }
  }
  
  /// 무도회장 조건: 사교적 요리사 (10개 레시피에서 3명 이상 언급)
  Future<bool> _checkBallroomCondition(Recipe triggerRecipe) async {
    final progress = await _getOrCreateProgress(SpecialRoom.ballroom, 10);
    
    // 이미 처리된 레시피면 스킵
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // 감정 스토리에서 사람 언급 체크
    final mentionedPeople = _extractMentionedPeople(triggerRecipe.emotionalStory);
    
    if (mentionedPeople.isNotEmpty) {
      // 새로 언급된 사람들을 메타데이터에 추가
      final existingPeople = Set<String>.from(progress.getMetadata<List>('mentionedPeople') ?? []);
      existingPeople.addAll(mentionedPeople);
      progress.setMetadata('mentionedPeople', existingPeople.toList());
      
      // 레시피 처리 마킹 및 카운트 증가
      if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
        progress.incrementCount();
        
        developer.log('Ballroom progress: ${progress.currentCount}/10, people: ${existingPeople.length}', 
                     name: 'BurrowUnlockService');
        
        await _saveProgress([progress]);
        
        // 조건 확인: 10개 레시피 + 3명 이상 언급
        return progress.isCompleted && existingPeople.length >= 3;
      }
    }
    
    return false;
  }
  
  /// 감정 스토리에서 사람 언급 추출
  Set<String> _extractMentionedPeople(String emotionalStory) {
    final people = <String>{};
    final story = emotionalStory.toLowerCase();
    
    // 한국어 관계 키워드들
    const relationKeywords = [
      '엄마', '아빠', '부모님', '어머니', '아버지',
      '가족', '형', '누나', '언니', '동생', '오빠',
      '친구', '동료', '선배', '후배', '동기',
      '남자친구', '여자친구', '연인', '애인', '남편', '아내',
      '할머니', '할아버지', '이모', '삼촌', '고모', '외삼촌',
      '아이', '딸', '아들', '손자', '손녀',
      '선생님', '교수님', '사장님', '팀장님',
      '이웃', '룸메이트', '반려동물'
    ];
    
    for (final keyword in relationKeywords) {
      if (story.contains(keyword)) {
        people.add(keyword);
      }
    }
    
    return people;
  }
  
  /// 온천탕 조건: 힐링 요리사 (sad/tired/nostalgic 각 3개씩)
  Future<bool> _checkHotSpringCondition(Recipe triggerRecipe) async {
    if (![Mood.sad, Mood.tired, Mood.nostalgic].contains(triggerRecipe.mood)) {
      return false; // 힐링 감정이 아니면 체크하지 않음
    }
    
    final progress = await _getOrCreateProgress(SpecialRoom.hotSpring, 9); // 총 9개 (각 3개씩)
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // 감정별 카운트 추적
    final moodCounts = Map<String, int>.from(progress.getMetadata<Map>('moodCounts') ?? {});
    final moodKey = triggerRecipe.mood.name;
    
    if ((moodCounts[moodKey] ?? 0) < 3) {
      moodCounts[moodKey] = (moodCounts[moodKey] ?? 0) + 1;
      progress.setMetadata('moodCounts', moodCounts);
      
      if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
        progress.incrementCount();
        
        developer.log('HotSpring progress: $moodCounts', name: 'BurrowUnlockService');
        
        await _saveProgress([progress]);
        
        // 조건 확인: sad, tired, nostalgic 각각 3개 이상
        return (moodCounts['sad'] ?? 0) >= 3 &&
               (moodCounts['tired'] ?? 0) >= 3 &&
               (moodCounts['nostalgic'] ?? 0) >= 3;
      }
    }
    
    return false;
  }
  
  /// 음악회장 조건: 감정 마에스트로 (8가지 감정 모두 완성, 평점 3+ )
  Future<bool> _checkOrchestraCondition(Recipe triggerRecipe) async {
    // 평점 3 미만이면 체크하지 않음
    if (triggerRecipe.rating == null || triggerRecipe.rating! < 3) {
      return false;
    }
    
    final progress = await _getOrCreateProgress(SpecialRoom.orchestra, 8); // 8가지 감정
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // 감정별 달성 여부 추적
    final achievedMoods = Set<String>.from(progress.getMetadata<List>('achievedMoods') ?? []);
    final moodKey = triggerRecipe.mood.name;
    
    if (!achievedMoods.contains(moodKey)) {
      achievedMoods.add(moodKey);
      progress.setMetadata('achievedMoods', achievedMoods.toList());
      
      if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
        progress.currentCount = achievedMoods.length; // 직접 설정
        
        developer.log('Orchestra progress: ${achievedMoods.length}/8 moods', name: 'BurrowUnlockService');
        
        await _saveProgress([progress]);
        
        // 조건 확인: 8가지 감정 모두 달성
        return achievedMoods.length >= 8;
      }
    }
    
    return false;
  }
  
  /// 연금술실 조건: 도전적 요리사 (실패→성공 3회)
  Future<bool> _checkAlchemyLabCondition(Recipe triggerRecipe) async {
    final progress = await _getOrCreateProgress(SpecialRoom.alchemyLab, 3);
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    // 동일한 제목의 이전 레시피들 찾기
    final allRecipes = await _hiveService.getAllRecipes();
    final sameTitle = triggerRecipe.title.toLowerCase().trim();
    
    final relatedRecipes = allRecipes.where((r) => 
        r.title.toLowerCase().trim() == sameTitle &&
        r.id != triggerRecipe.id &&
        r.rating != null
    ).toList();
    
    if (relatedRecipes.isNotEmpty) {
      // 이전 평점 중 2점 이하가 있고, 현재 평점이 4점 이상인지 체크
      final hasFailure = relatedRecipes.any((r) => r.rating! <= 2);
      final currentSuccess = triggerRecipe.rating != null && triggerRecipe.rating! >= 4;
      
      if (hasFailure && currentSuccess) {
        if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
          progress.incrementCount();
          
          developer.log('AlchemyLab progress: ${progress.currentCount}/3 improvements', name: 'BurrowUnlockService');
          
          await _saveProgress([progress]);
          
          return progress.isCompleted;
        }
      }
    }
    
    return false;
  }
  
  /// 파인다이닝 조건: 완벽주의자 (평점 5점 레시피 10개)
  Future<bool> _checkFineDiningCondition(Recipe triggerRecipe) async {
    if (triggerRecipe.rating != 5) {
      return false; // 5점이 아니면 체크하지 않음
    }
    
    final progress = await _getOrCreateProgress(SpecialRoom.fineDining, 10);
    
    if (progress.hasProcessedRecipe(triggerRecipe.id)) {
      return false;
    }
    
    if (progress.markRecipeAsProcessed(triggerRecipe.id)) {
      progress.incrementCount();
      
      developer.log('FineDining progress: ${progress.currentCount}/10 perfect recipes', name: 'BurrowUnlockService');
      
      await _saveProgress([progress]);
      
      return progress.isCompleted;
    }
    
    return false;
  }
  
  /// 진행상황 가져오기 또는 생성
  Future<UnlockProgress> _getOrCreateProgress(SpecialRoom room, int requiredCount) async {
    final progressList = await _loadProgress();
    final existing = progressList.firstWhere(
      (p) => p.roomType == room,
      orElse: () => UnlockProgress(roomType: room, requiredCount: requiredCount),
    );
    
    return existing;
  }
  
  /// 언락 큐에서 다음 아이템 가져오기 (순차 처리용)
  UnlockQueueItem? popUnlockQueue() {
    if (_unlockQueue.isEmpty) return null;
    return _unlockQueue.removeAt(0);
  }
  
  /// 언락 큐 크기 
  int get unlockQueueSize => _unlockQueue.length;
  
  /// 모든 마일스톤 가져오기
  Future<List<BurrowMilestone>> getAllMilestones() async {
    return await _loadMilestones();
  }
  
  /// 성장 트랙 마일스톤들 가져오기
  Future<List<BurrowMilestone>> getGrowthMilestones() async {
    final milestones = await _loadMilestones();
    return milestones.where((m) => m.isGrowthTrack).toList()
      ..sort((a, b) => a.level.compareTo(b.level));
  }
  
  /// 특별 공간 마일스톤들 가져오기
  Future<List<BurrowMilestone>> getSpecialMilestones() async {
    final milestones = await _loadMilestones();
    return milestones.where((m) => m.isSpecialRoom).toList();
  }
  
  /// 현재 진행상황들 가져오기 (디버그용)
  Future<List<UnlockProgress>> getCurrentProgress() async {
    return await _loadProgress();
  }
  
  // === Hive 저장/로드 헬퍼 메서드들 ===
  
  /// 마일스톤들 로드
  Future<List<BurrowMilestone>> _loadMilestones() async {
    try {
      return await _storageService.loadMilestones();
    } catch (e) {
      developer.log('Failed to load milestones: $e', name: 'BurrowUnlockService');
      return [];
    }
  }
  
  /// 단일 마일스톤 업데이트 (public)
  Future<void> updateMilestone(BurrowMilestone milestone) async {
    try {
      await _storageService.updateMilestone(milestone);
      developer.log('Updated milestone: ${milestone.title}', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to update milestone: $e', name: 'BurrowUnlockService');
      rethrow;
    }
  }

  /// 마일스톤들 업데이트
  Future<void> _updateMilestones(List<BurrowMilestone> milestones) async {
    try {
      await _storageService.updateMilestones(milestones);
      developer.log('Updated ${milestones.length} milestones', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to update milestones: $e', name: 'BurrowUnlockService');
    }
  }
  
  /// 진행상황들 저장
  Future<void> _saveProgress(List<UnlockProgress> progressList) async {
    try {
      await _storageService.saveProgress(progressList);
      developer.log('Saved ${progressList.length} progress items', name: 'BurrowUnlockService');
    } catch (e) {
      developer.log('Failed to save progress: $e', name: 'BurrowUnlockService');
    }
  }
  
  /// 진행상황들 로드
  Future<List<UnlockProgress>> _loadProgress() async {
    try {
      return await _storageService.loadProgress();
    } catch (e) {
      developer.log('Failed to load progress: $e', name: 'BurrowUnlockService');
      return [];
    }
  }
}